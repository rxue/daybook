# Part 2. Mapping strategies
## Chapter 4. Mapping persistent classes
### 4.1. Understanding *entities* and *value types*
#### 4.1.1. Fine-grained domain models
design tip: when designing an `EmailAddress` *value* class, it may provide a `prepareEmail()` method (but not `sendEmail()` because it is a bad idea to make this `EmailAddress` class have dependency on the email sub-system)
#### 4.1.2. Defining application concepts
design tip: 
 * since you want to have CRUD operation on `User` => `User` is an entity
 * take `Address` as an example, if there exists `Address` being shared among multiple `User` then the `Address` is an `Entity` - think about it, when removing a `User` you cannot remove the `Address` if it is shared by other users

> An instance of *value type* has no persistence identifier property, it belongs to an entity instance. Its lifespan is bound to the owning entity instance. => A value type doesn't support shared references. 

#### 4.1.3. Distinguishing entities and value types
design tip: 
 * use stereotype in UML to differentiate between *entity* and *value type*
 * relationship between an entity and its *value types* is *composition* especially from the lifecycle aspect
 * prefer always *value type* to *entity* (this kinda corresponds to the OO design principle - favor composition over inheritance)
 * strive for simplicity: persistent collections, e.g., frequently add complexity without any benifit. For instance, instead of mapping `Item#bids` and `User#bids`, query all `bids` for `Item`/`User`
3 key things in JPA design:
 * shared references
 * life-cycle dependencies
 * identity

### 4.2. Mapping entities with identity
*database identity* : Objects stored in database are identical if they share the same table and primary key value
#### 4.2.2. A first entity class and mapping
`Long getId()` is optional but useful

> Hibernate will use the field to access the identifier property value when loading and storing items, not *getter* or *setter* method.

design tip: `setId()` method can be added, but it is not necessary and in practice it might add complexity to the whole system

#### 4.2.3. Selecting a primary key
*candidate key* : a column or set of columns that could be used to identify a single row in a table.

Requirement on candidate key:
 * value of any candidate key column cannot not be null
 * uniqueness
 * *immutable* (this indicates why no need a `setId()` method on an entity usually)

*natural key* : a key with business meaning - an attribute or combination of attributes that is unique by virtual of its business semantics
Example of *natural keys* : social security number, Australian Tax File Number etc.

practical experience: *natural key* as *primary key* usually end up with problems!
=> 
recommendation: *surrogate keys* as *primary key* 
surrogate key: no business meaning: a unique value generated by the database or application

#### 4.2.4. Configuring key generators
#### 4.2.5. Identifier generator strategies
design tip: prefer pre-insert generation strategies that produce identifier values independently before `insert` - database `sequence`

learning:
> Autoincremented columns, column default values, or trigger-generated keys are only available **after the `INSERT`**
### 4.3. Entity-mapping options
#### 4.3.1 Controlling names
Learning: SQL is case-insensitive

Override table name - `@Table(name="new_name")`

#### 4.3.3. Make an entity *immutable*
design tip: 
* *immutable* (not JPA stanadard but only Hibernate feature) entity avoids *dirty checking* => performance improvement
* JSF doesn't access fields directly to populate an instance
#### 4.3.4. Mapping an entity a sub-select

## Chapter 5. Mapping Value Types

Category of *value types* (class) :
 * basic: `String`, `Date`
 * developer-defined/custom
### 5.1. Mapping basic properties
design tip: Always map Java classes instead of storing a heap of bytes in the database

*configuration by exception*
#### 5.1.1. Overriding basic property defaults



design tip: favor `@Column` over `@Basic`
#### 5.1.2. Customizing property access
design type: 
 * if `@Id` is placed on a field => all other JPA annotations are also on fields
 * IMPORTANT: annotations are never on the setter methods!

default `AccessType` is `FIELD` in `@Access` (how instance is accessed). `AccessType.PROPERTY` means to parse annotations from *getter* methods

#### 5.1.3. Using derived properties (Hibernate features)
#### 5.1.4. Transforming column values (Hibernate features)
#### 5.1.5. Generated and default property values (Hibernate features)
#### 5.1.6. *Temporal* properties
`@Temporal`
design tip: timestamp property is saved once by never updated
#### 5.1.7. Mapping annotations
design tip: `EnumType.STRING` is a better choice
### 5.2. Mapping embeddable components
#### 5.2.1. Database schema
*value type* can't be shared => *value type* has no identity. 

an *embedded component* has a dependent lifecycle (dependent on its owning entity)

#### 5.2.2. Making classes embeddable 
`@Embeddable` class has no identifier property

### 5.3. Mapping Java and SQL types with converters
*Java-to-SQL type conversion*
#### 5.3.1. built-in types
##### Primitives and Numeric Types

#### 5.3.2. Creating Custom JPA Converters
*value-typed class* 
 * *immutable* 
 * should `implements Serializable` when Hibernate stores entity instance data in the shared second-level cache
##### CONVERTING BASIC PROPERTY VALUES
A *converter* must 
 * `implements AttributeConverter`
 * annotate with `@Converter`: `autoPlay` comes into play typically when an type class is used as an attribute in many different entities inside the same *persitance unit* and, we might want to convert it differently as to different entities

NOTE! use of `@Convert` onto the field of entity is optional. It comes into use typically when there are multiple `AttributeConverter` implementions on the same field class type, then it is necessary to define the `converter` element of the `@Convert` annotation. The other element `disabled` is trivial to understand

##### Character Types

## Chapter 6. Mapping Inheritance
### 6.8 *Polymorphic associations*
#### 6.8.1 Polymorphic *many-to-one* associations
#### 6.8.2 Polymorphic collections
example of `abstract class` entity with `@Entity` annotation: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/model/src/main/java/org/jpwh/model/inheritance/associations/onetomany/BillingDetails.java

label: `1Z0-900`

## Chapter 7. Managing collections and entity associations
Heart of ORM : manage associations between classes and relationships between tables
**Major new features in JPA 2**
### 7.1. Sets, bags, lists and maps of value types
#### Selecting a collection interface
`java.util.Collection` - *bag* semantics
#### 7.1.5. Mapping an identifier *bag*
*Bag* : an *unordered collection* that allows duplicate elements

### 7.2. Collections of components
#### 7.2.2. Set of components

### 7.3. Mapping entity associations
> The term *parent/child* implies some kind of *life cycle dependencies*

*Association* between entity classes don't have a dependent life cycle: An instance can be saved, updated, and removed without affecting any other

#### 7.3.1. The simplest possible association
> when you see a *foreign key* column and two entity classes involved, you should probably map it with `@ManyToOne` and nothing else

**My own practice of unidirectional `@OneToMany`:** https://github.com/rxue/dictionary/issues/129

#### 7.3.2. Making it bidirectional
primary benifit of `@OneToMany` : *navigational access* to data

## Chapter 8. Advanced entity association mappings
### 8.2 one-to-many associations

