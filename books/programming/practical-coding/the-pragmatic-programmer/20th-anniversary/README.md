# From the Preface to the First Edition
## Individual Pragmatists, Large Teams
Book's quote

> We who cut merestones must always be envisioning cathedrals

> One hundred years from now, our engineering may seem as archaic as the techniques used by medieval cathedral builders seem to today’s civil engineers, while our craftsmanship will still be honored. 
# Chapter 1: A Pragmatic Philosophy
What distinguishes Programtic Programmers? They think beyong the immediate problem, placing it in its larger context and seeking out the bigger picture.
## Topic 3 Software Entropy

*entropy* : a term from physics that refers to the amount of "disorder" in a system
## Topic 4. Stone Soup and Boiled Frogs
### The Villagers' Side
**Remember the Big Picture**

Don't be like the fabled frog. Keep an eye on the big picture. Constantly review what's happening around you, not just what you personally are doing.
## Topic 5. Good-Enough Software
**Tip 8: Make Quality a Requirements Issue**
many users would rather use software with some rough edges today than wait a year for the shiny, bells-and-whistles version

> If you give you users something to play with early, their feedback will often lead you to a better eventual solution
### KNOW WHEN TO STOP

> Don't spoil a perfectly good program by overembellishment and overrefinement.
## Topic 8. Your Knowledge Portfolio
### CRITICAL THINKING
**Tip 10: Critically Analyze What Your Read and Hear**
*What's the context*
> Everything occurs in its own context, which is why "one size fits all" solutions often don't.

# Chapter 2: A Pragmatic Approach
## Topic 10 Orthogonality
### Coding
> Unless you constantly monitor not just what you are doing but also the **larger context of the application**, you might unintentionally duplicate functionality in some other module, or express existing knowledge twice


## Topic 12 Tracer Bullets
*tracer bullet development* - immediate feedback

### CODE THAT GLOWS IN THE DARK

 * look for areas where you have doubts, and where you see the biggest risks

### TRACER BULLETS DON'T ALWAYS HIT THEIR TARGET

use trace code development in case you are not 100% certain of where you're going.

> You shouldn't be surprised if your first couple of attempts miss: the user says "that's not what I meant," or data you need isn't available when you need it, or ... So change what youäve got to bring it nearer the target, and be thankful that you've used a lean development methodology; a small body of code has low inertia - it is easy and quick to change.

### TRACER CODE VERSUS PROTOTYPING

## Topic 14 Domain Languages
### Tip 22 Program Close to the Problem Domain
#### Trade-offs Between Internal and External Languages

# Chapter 3: The Basic Tools
## Topic 17. Shell Games
**Tip 16: Use the Power of Command Shells**
#### A SHELL OF YOUR OWN
* Setting color themes
* Aliases and Shell functions
* *Command completion* : type the first few characters, hit **tab**, and it'll fill in what it can. Furthermore, the command completion can be *context-specific* 

**COMMENT**
Practical application of *alias*:
* alias in IntelliJ, e.g. `psvm`

Practical application of *Command completion*:
* *tab* key in terminal in Linux/MacBook
* `git` can be configured to support command completion with *tab* in terminal
* *postfix completion* in IntelliJ

## Topic 20. Debugging
### DEBUGGING STRATEGIES
#### Reproducing Bugs
**Tip 31: Failing Test Before Fixing Code*

### CODE IN A STRANGE LAND
**Tip 32: Read the Damn Error Message**
### THE BINARY CHOP
aka. *binary search*
#### Logging and/or Tracing

# Chapter 7: While You Are Coding
*pattern language*

