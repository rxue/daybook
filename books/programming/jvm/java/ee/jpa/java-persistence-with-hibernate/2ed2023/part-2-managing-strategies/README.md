# Part 2. Mapping strategies
## Chapter 4. Mapping persistent classes
### 4.1. Understanding *entities* and *value types*
#### 4.1.1. Fine-grained domain models
design tip: when designing an `EmailAddress` *value* class, it may provide a `prepareEmail()` method (but not `sendEmail()` because it is a bad idea to make this `EmailAddress` class have dependency on the email sub-system)
#### 4.1.2. Defining application concepts
design tip: 
 * since you want to have CRUD operation on `User` => `User` is an entity
 * take `Address` as an example, if there exists `Address` being shared among multiple `User` then the `Address` is an `Entity` - think about it, when removing a `User` you cannot remove the `Address` if it is shared by other users

> An instance of *value type* has no persistence identifier property, it belongs to an entity instance. Its lifespan is bound to the owning entity instance. => A value type doesn't support shared references. 

#### 4.1.3. Distinguishing entities and value types
design tip: 
 * use stereotype in UML to differentiate between *entity* and *value type*
 * relationship between an entity and its *value types* is *composition* especially from the lifecycle aspect
 * prefer always *value type* to *entity* (this kinda corresponds to the OO design principle - favor composition over inheritance)
 * strive for simplicity: persistent collections, e.g., frequently add complexity without any benifit. For instance, instead of mapping `Item#bids` and `User#bids`, query all `bids` for `Item`/`User`
3 key things in JPA design:
 * shared references
 * life-cycle dependencies
 * identity

### 4.2. Mapping entities with identity
*database identity* : Objects stored in database are identical if they share the same table and primary key value
#### 4.2.2. A first entity class and mapping
`Long getId()` is optional but useful

> Hibernate will use the field to access the identifier property value when loading and storing items, not *getter* or *setter* method.

design tip: `setId()` method can be added, but it is not necessary and in practice it might add complexity to the whole system

#### 4.2.3. Selecting a primary key
*candidate key* : a column or set of columns that could be used to identify a single row in a table.

Requirement on candidate key:
 * value of any candidate key column cannot not be null
 * uniqueness
 * *immutable* (this indicates why no need a `setId()` method on an entity usually)

*natural key* : a key with business meaning - an attribute or combination of attributes that is unique by virtual of its business semantics
Example of *natural keys* : social security number, Australian Tax File Number etc.

practical experience: *natural key* as *primary key* usually end up with problems!
=> 
recommendation: *surrogate keys* as *primary key* 
surrogate key: no business meaning: a unique value generated by the database or application

#### 4.2.4. Configuring key generators
#### 4.2.5. Identifier generator strategies
design tip: prefer pre-insert generation strategies that produce identifier values independently before `insert` - database `sequence`

learning:
> Autoincremented columns, column default values, or trigger-generated keys are only available **after the `INSERT`**
### 4.3. Entity-mapping options
#### 4.3.1 Controlling names
Learning: SQL is case-insensitive

Override table name - `@Table(name="new_name")`

#### 4.3.3. Make an entity *immutable*
design tip: 
* *immutable* (not JPA stanadard but only Hibernate feature) entity avoids *dirty checking* => performance improvement
* JSF doesn't access fields directly to populate an instance
#### 4.3.4. Mapping an entity a sub-select

## Chapter 5. Mapping Value Types

Category of *value types* (class) :
 * basic: `String`, `Date`
 * developer-defined/custom
### 5.1. Mapping basic properties
design tip: Always map Java classes instead of storing a heap of bytes in the database

*configuration by exception*
#### 5.1.1. Overriding basic property defaults



design tip: favor `@Column` over `@Basic`
#### 5.1.2. Customizing property access
design type: 
 * if `@Id` is placed on a field => all other JPA annotations are also on fields
 * IMPORTANT: annotations are never on the setter methods!

default `AccessType` is `FIELD` in `@Access` (how instance is accessed). `AccessType.PROPERTY` means to parse annotations from *getter* methods

#### 5.1.3. Using derived properties (Hibernate features)
#### 5.1.4. Transforming column values (Hibernate features)
#### 5.1.5. Generated and default property values (Hibernate features)
#### 5.1.6. *Temporal* properties
`@Temporal` - **accuracy** of SQL data type
#### 5.1.7. Mapping annotations
design tip: `EnumType.STRING` is a better choice
### 5.2. Mapping embeddable components
#### 5.2.1. Database schema
*value type* can't be shared => *value type* has no identity. 

an *embedded component* has a dependent lifecycle (dependent on its owning entity)

#### 5.2.2. Making classes embeddable 
`@Embeddable` class has no identifier property

#### 5.2.3. Overriding embedded attributes
`@Embedded` annotation is not necessary

### 5.3. Mapping Java and SQL types with converters
*Java-to-SQL type conversion*
#### 5.3.1. built-in types
##### Primitives and Numeric Types

#### 5.3.2. Creating Custom JPA Converters
*value-typed class* 
 * *immutable* 
 * should `implements Serializable` when Hibernate stores entity instance data in the shared second-level cache
##### CONVERTING BASIC PROPERTY VALUES
A *converter* must 
 * `implements AttributeConverter`
 * annotate with `@Converter`: `autoPlay` comes into play typically when an type class is used as an attribute in many different entities inside the same *persitance unit* and, we might want to convert it differently as to different entities

NOTE! use of `@Convert` onto the field of entity is optional. It comes into use typically when there are multiple `AttributeConverter` implementions on the same field class type, then it is necessary to define the `converter` element of the `@Convert` annotation. The other element `disabled` is trivial to understand

##### Character Types

## Chapter 6. Mapping Inheritance
### 6.8 *Polymorphic associations*
#### 6.8.1 Polymorphic *many-to-one* associations

**SELF COMMENT**
In practice, use of `@ManyToOne(fetch = FetchType.LAZY)` in combination with *JsonB* causes error because
> Hibernate will proxy the association target

```
05:42:49,506 SEVERE [org.eclipse.yasson.internal.SerializationContextImpl] (default task-1) Generating incomplete JSON
05:42:49,511 ERROR [org.jboss.resteasy.core.providerfactory.DefaultExceptionMapper] (default task-1) RESTEASY002375: Error processing request GET /dictionary-rest-api/rest/glossary/en/take - rx.dictionary.rest.DictionaryResource.getDictionaryEntry: jakarta.ws.rs.ProcessingException: RESTEASY008205: JSON Binding serialization error jakarta.json.bind.JsonbException: Unable to serialize property 'lexicalItem' from io.github.rxue.dictionary.jpa.entity.Explanation
	at org.jboss.resteasy.resteasy-json-binding-provider@6.2.1.Final//org.jboss.resteasy.plugins.providers.jsonb.JsonBindingProvider.asyncWriteTo(JsonBindingProvider.java:234)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.writeTo(ServerWriterInterceptorContext.java:87)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.AbstractWriterInterceptorContext.asyncProceed(AbstractWriterInterceptorContext.java:203)
	at org.jboss.resteasy.resteasy-crypto@6.2.1.Final//org.jboss.resteasy.security.doseta.DigitalSigningInterceptor.asyncAroundWriteTo(DigitalSigningInterceptor.java:169)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.AbstractWriterInterceptorContext.asyncProceed(AbstractWriterInterceptorContext.java:211)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.AbstractWriterInterceptorContext.getStarted(AbstractWriterInterceptorContext.java:166)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.lambda$getStarted$0(ServerWriterInterceptorContext.java:73)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.aroundWriteTo(ServerWriterInterceptorContext.java:93)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ServerWriterInterceptorContext.getStarted(ServerWriterInterceptorContext.java:73)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.lambda$writeNomapResponse$3(ServerResponseWriter.java:172)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.ContainerResponseContextImpl.filter(ContainerResponseContextImpl.java:410)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.executeFilters(ServerResponseWriter.java:261)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.writeNomapResponse(ServerResponseWriter.java:101)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.ServerResponseWriter.writeNomapResponse(ServerResponseWriter.java:74)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.writeResponse(SynchronousDispatcher.java:594)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:524)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.lambda$invoke$4(SynchronousDispatcher.java:261)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.lambda$preprocess$0(SynchronousDispatcher.java:161)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.interception.jaxrs.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:364)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.preprocess(SynchronousDispatcher.java:164)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:247)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:249)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:60)
	at org.jboss.resteasy.resteasy-core@6.2.1.Final//org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:55)
	at jakarta.servlet.api@6.0.0//jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129)
	at io.smallrye.opentracing-contrib//io.smallrye.opentracing.contrib.jaxrs2.server.SpanFinishingFilter.doFilter(SpanFinishingFilter.java:69)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:67)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
	at org.wildfly.security.elytron-web.undertow-server@3.0.0.Final//org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler.lambda$handleRequest$1(ElytronRunAsHandler.java:68)
	at org.wildfly.security.elytron-base@2.0.0.Final//org.wildfly.security.auth.server.FlexibleIdentityAssociation.runAsFunctionEx(FlexibleIdentityAssociation.java:103)
	at org.wildfly.security.elytron-base@2.0.0.Final//org.wildfly.security.auth.server.Scoped.runAsFunctionEx(Scoped.java:161)
	at org.wildfly.security.elytron-base@2.0.0.Final//org.wildfly.security.auth.server.Scoped.runAs(Scoped.java:73)
	at org.wildfly.security.elytron-web.undertow-server@3.0.0.Final//org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler.handleRequest(ElytronRunAsHandler.java:67)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.RedirectDirHandler.handleRequest(RedirectDirHandler.java:68)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:117)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.core@2.3.0.Final//io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)
	at io.undertow.core@2.3.0.Final//io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)
	at org.wildfly.security.elytron-web.undertow-server-servlet@3.0.0.Final//org.wildfly.elytron.web.undertow.server.servlet.CleanUpHandler.handleRequest(CleanUpHandler.java:38)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.GlobalRequestControllerHandler.handleRequest(GlobalRequestControllerHandler.java:68)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.SendErrorPageHandler.handleRequest(SendErrorPageHandler.java:52)
	at io.undertow.core@2.3.0.Final//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:275)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:134)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:131)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at org.wildfly.extension.undertow@27.0.0.Final//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1435)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:255)
	at io.undertow.servlet@2.3.0.Final//io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:100)
	at io.undertow.core@2.3.0.Final//io.undertow.server.Connectors.executeRootHandler(Connectors.java:391)
	at io.undertow.core@2.3.0.Final//io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:859)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1990)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)
	at org.jboss.threads@2.4.0.Final//org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1348)
	at org.jboss.xnio@3.8.8.Final//org.xnio.XnioWorker$WorkerThreadFactory$1$1.run(XnioWorker.java:1282)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: jakarta.json.bind.JsonbException: Unable to serialize property 'lexicalItem' from io.github.rxue.dictionary.jpa.entity.Explanation
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:43)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:721)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.serialize(ObjectSerializer.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.RecursionChecker.serialize(RecursionChecker.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.KeyWriter.serialize(KeyWriter.java:41)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullVisibilitySwitcher.serialize(NullVisibilitySwitcher.java:40)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.findSerializer(ObjectTypeSerializer.java:68)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serializeValue(ObjectTypeSerializer.java:50)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer$ValueSerializer.serialize(TypeSerializer.java:51)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer.serialize(TypeSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serialize(ObjectTypeSerializer.java:31)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.CollectionSerializer.lambda$serialize$0(CollectionSerializer.java:37)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.CollectionSerializer.serialize(CollectionSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.KeyWriter.serialize(KeyWriter.java:41)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullVisibilitySwitcher.serialize(NullVisibilitySwitcher.java:40)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.SerializationContextImpl.serializeObject(SerializationContextImpl.java:197)
	at org.eclipse.yasson//org.eclipse.yasson.internal.SerializationContextImpl.marshall(SerializationContextImpl.java:133)
	at org.eclipse.yasson//org.eclipse.yasson.internal.SerializationContextImpl.marshall(SerializationContextImpl.java:159)
	at org.eclipse.yasson//org.eclipse.yasson.internal.JsonBinding.toJson(JsonBinding.java:121)
	at org.jboss.resteasy.resteasy-json-binding-provider@6.2.1.Final//org.jboss.resteasy.plugins.providers.jsonb.ManagedJsonb.toJson(ManagedJsonb.java:78)
	at org.jboss.resteasy.resteasy-json-binding-provider@6.2.1.Final//org.jboss.resteasy.plugins.providers.jsonb.JsonBindingProvider.asyncWriteTo(JsonBindingProvider.java:223)
	... 72 more
Caused by: jakarta.json.bind.JsonbException: Unable to serialize property 'hibernateLazyInitializer' from io.github.rxue.dictionary.jpa.entity.LexicalItem$HibernateProxy$0lYwZSxP
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:43)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:721)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.serialize(ObjectSerializer.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.RecursionChecker.serialize(RecursionChecker.java:38)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.KeyWriter.serialize(KeyWriter.java:41)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullVisibilitySwitcher.serialize(NullVisibilitySwitcher.java:40)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.findSerializer(ObjectTypeSerializer.java:68)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serializeValue(ObjectTypeSerializer.java:50)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer$ValueSerializer.serialize(TypeSerializer.java:51)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer.serialize(TypeSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serialize(ObjectTypeSerializer.java:31)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ValueGetterSerializer.serialize(ValueGetterSerializer.java:43)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:41)
	... 96 more
Caused by: jakarta.json.bind.JsonbException: Error accessing getter 'getEnclosingConstructor' declared in 'class java.lang.Class'
	at org.eclipse.yasson//org.eclipse.yasson.internal.model.PropertyModel.createReadHandle(PropertyModel.java:500)
	at org.eclipse.yasson//org.eclipse.yasson.internal.model.PropertyModel.<init>(PropertyModel.java:157)
	at org.eclipse.yasson//org.eclipse.yasson.internal.ClassParser.lambda$parseProperties$0(ClassParser.java:70)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$ValueSpliterator.forEachRemaining(HashMap.java:1779)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at org.eclipse.yasson//org.eclipse.yasson.internal.ClassParser.parseProperties(ClassParser.java:71)
	at org.eclipse.yasson//org.eclipse.yasson.internal.MappingContext.lambda$createParseClassModelFunction$1(MappingContext.java:104)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1740)
	at org.eclipse.yasson//org.eclipse.yasson.internal.MappingContext.getOrCreateClassModel(MappingContext.java:77)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChainInternal(SerializationModelCreator.java:187)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChain(SerializationModelCreator.java:137)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.memberSerializer(SerializationModelCreator.java:378)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.createObjectSerializer(SerializationModelCreator.java:213)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChainInternal(SerializationModelCreator.java:199)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.SerializationModelCreator.serializerChainRuntime(SerializationModelCreator.java:123)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.lambda$findSerializer$0(ObjectTypeSerializer.java:67)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.findSerializer(ObjectTypeSerializer.java:65)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serializeValue(ObjectTypeSerializer.java:50)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer$ValueSerializer.serialize(TypeSerializer.java:51)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.TypeSerializer.serialize(TypeSerializer.java:37)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.types.ObjectTypeSerializer.serialize(ObjectTypeSerializer.java:31)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.NullSerializer.serialize(NullSerializer.java:67)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ValueGetterSerializer.serialize(ValueGetterSerializer.java:43)
	at org.eclipse.yasson//org.eclipse.yasson.internal.serializer.ObjectSerializer.lambda$serialize$0(ObjectSerializer.java:41)
	... 110 more
Caused by: java.lang.IllegalAccessException: Attempt to lookup caller-sensitive method using restricted lookup object
	at java.base/java.lang.invoke.MethodHandles$Lookup.findBoundCallerLookup(MethodHandles.java:3714)
	at java.base/java.lang.invoke.MethodHandles$Lookup.unreflect(MethodHandles.java:3350)
	at org.eclipse.yasson//org.eclipse.yasson.internal.model.PropertyModel.createReadHandle(PropertyModel.java:497)
	... 139 more
```

In order to avoid the error mentioned above, You can avoid these issues by forcing eager fetch with `fetch` keyword in the JPQL

reference: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/examples/src/test/java/org/jpwh/test/inheritance/PolymorphicManyToOne.java

#### 6.8.2 Polymorphic collections
example of `abstract class` entity with `@Entity` annotation: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/model/src/main/java/org/jpwh/model/inheritance/associations/onetomany/BillingDetails.java

label: `1Z0-900`

## Chapter 7. Managing collections and entity associations
Heart of ORM : manage associations between classes and relationships between tables
**Major new features in JPA 2**
### 7.1. Sets, bags, lists and maps of value types
#### Selecting a collection interface
`java.util.Collection` - *bag* semantics
#### 7.1.5. Mapping an identifier *bag*
*Bag* : an *unordered collection* that allows duplicate elements

### 7.2. Collections of components
#### 7.2.2. Set of components

### 7.3. Mapping entity associations
> The term *parent/child* implies some kind of *life cycle dependencies*

*Association* between entity classes don't have a dependent life cycle: An instance can be saved, updated, and removed without affecting any other

#### 7.3.1. The simplest possible association
> when you see a *foreign key* column and two entity classes involved, you should probably map it with `@ManyToOne` and nothing else

**My own practice of unidirectional `@OneToMany`:** https://github.com/rxue/dictionary/issues/129

#### 7.3.2. Making it bidirectional
demo code reference: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/model/src/main/java/org/jpwh/model/associations/onetomany/bidirectional/Bid.java

Mapping collection in `@OneToMany` association has the following 2 features:
* *lazy load* on the collection, in the example the `Bid` collection is loaded only when `item.getBids()` is called => primary benifit of `@OneToMany`: *navigational access* to data - access data data by calling only methods of Java *domain model*
* *cascade* state change: typically on *delete* and *save* operation (configurable)


primary benifit of `@OneToMany`: *navigational access* to data - access data data by calling only methods of Java *domain model*

But in practice, ask yourself do you always need all of the *many* side of `@OneToMany`, i.e. the `Bid` collections in the example? **If you usually need only a *subset* of the collection or need sorting, the extra Java code brings about significant complexity! This is the mentioned *maintenance baggage*** As to such case, the author mentioned:

> In our experience, this is frequent source of problems and bugs, especially for ORM beginners

`mappedBy` element is compulsory on the *one* side of the `@OneToMany` association

#### 7.3.3. Cascading state
demo code: http://jpwh.org/examples/jpwh2/jpwh-2e-examples-20151103/examples/src/test/java/org/jpwh/test/associations/OneToManyBidirectional.java

## Chapter 8. Advanced entity association mappings
### 8.2 one-to-many associations

## Chapter 9. Complex and legacy schemas
### 9.1. Improving the database schema
#### 9.1.2. SQL Constraints
> Systems that ensure data integrity only in application code are prone to data corruption and often degrade the quality of the database over time. If the data store doesn’t enforce rules, a trivial undetected application bug can cause unrecoverable problems such as incorrect or lost data.
